# Configure logs
# locate and interpret system log files and journals
# preserve system journals

# What is system logging: 
 It is the mechanism by which a computer's operating system, its running services, and applications record events of interest. 
 Think of it as the "black box" or the "flight recorder" for your computer.
 These logs are sequential text files (though they can be in a binary format for efficiency) that contain timestamped messages. 
 They provide a continuous, historical record of everything that happens on the system, from routine status updates to critical security alerts.

man -k systemd | tail

### 2. What Comes In It? (The Contents of Logs)
Log entries are generated by a wide variety of system components. Here are the most common sources:

*   The Linux Kernel: Messages about hardware detection, driver errors, filesystem issues, and other low-level events. 
                        (e.g., `kernel: usb 2-1.2: new high-speed USB device number 5 using ehci-pci`)
*   System Services (Daemons): Services like web servers (Apache/Nginx), SSH, cron, and databases log their activity, errors, and connections. 
			(e.g., `sshd[1234]: Accepted password for user from 192.168.1.10 port 54322`)
*   Systemd itself: Logs for the boot process, service failures, and state changes of units. 
			(e.g., `systemd[1]: Started User Manager for UID 1000.`)
*   Security & Authentication: Successful and failed login attempts, privilege escalations (sudo), and firewall events. This is crucial for auditing and security.
*   Applications: User-level applications often write to system logs or their own application-specific log files.
*   System Events: Shutdowns, reboots, and scheduled tasks (cron jobs).

A typical log line looks like this:
			`May 15 10:23:45 my-server sshd[1234]: Accepted publickey for user from 192.168.1.100 port 55122 ssh2`

*   `May 15 10:23:45`: Timestamp
*   `my-server`: Hostname
*   `sshd[1234]`: The application/process and its PID
*   `Accepted publickey...`: The actual event message.

### 3. Why Do We Use It? (The Purpose)
Logging is not just for when things go wrong; it's essential for many aspects of system management:

1.  Debugging and Troubleshooting: This is the most common use. 
--- When a service fails, a website goes down, or hardware acts strangely, the log files are the first place to look for error messages and clues.
2.  Security and Auditing: Logs are vital for detecting intrusion attempts, malicious activity, and policy violations. 
--- They allow you to answer questions like "Who logged in and when?" or "Was there a failed login attempt for the root account?"
3.  Performance Monitoring: By analyzing logs over time, you can identify trends, spot resource bottlenecks, and understand system usage patterns.
4.  Forensics: After a security incident, logs provide a timeline of events to understand how the breach occurred and what the attacker did.
5.  Compliance: Many industry regulations (like PCI DSS, HIPAA, SOX) require logging and the retention of those logs for a specific period to prove the security and integrity of systems.


### 4. The Tools: systemd-journald, rsyslog, and Direct Writes
Modern Linux systems (most distributions since ~2015) use a combination of these tools.

#### systemd-journald - MODERN
#=================================#
*   What it is: The newer, default logging system introduced by `systemd`. It's more than just a daemon; it's integrated into the core of the OS.
*  Key Characteristics:
    *   Binary Format: It doesn't write to plain text files by default. Instead, it uses a binary, indexed file (usually `/var/log/journal/`). 
	This allows for much faster queries and richer metadata (like _PID, UID, GID, SELinux context_).
    *   Centralized Storage: It collects messages from the kernel (read from `kmsg`), early boot stages, and all systemd services via their std output (`stdout`) and std error (`stderr`).
    *   Temporary by Default: On some distributions, the journal is stored only in memory (`/run/log/journal/`) by default and is lost on reboot. 
	To make it persistent, you create the directory `/var/log/journal/` and restart `journald`.

*   How to use it: The primary tool to query the journal is `journalctl`.
	
	man -k journalctl
# useful options
-f = live logs
-b = bootlogs
-x = additional explaination on the logged item
-u = to filter specific unit only
-p = filtering of messages based on priority

    * journalctl									: View all logs
    * journalctl -u nginx.service							: View logs for the nginx service
    * journalctl -f									: Follow (tail) new log entries
    * journalctl --since "2023-05-15 09:00:00"						: Show logs since a specific time
    * journalctl --since "2025-07-01 00:00:00" --until "2025-08-01 23:59:59"		: show logs between two time limits
    * journalctl --since "2025-07-01" --until "2025-08-02" -u nginx.service		: show logs between two time limits for specific services like SSH, Docker, etc
    * journalctl _PID=1234								: Show logs for a specific Process ID (shows the power of metadata)

#### rsyslogd (or syslog) - OLD
#===============================#
*   What it is: The traditional, mature, and highly robust logging daemon. 
                `rsyslog` is the "rocket-fast" enhanced version of the original `sysklogd`. 
		It follows the classic syslog protocol.
*   Key Characteristics:
    *   Text-Based: It writes to classic, human-readable text files in `/var/log/` (e.g., `syslog`, `auth.log`, `kern.log`).
    *   Filtering and Routing: Its superpower is its ability to filter messages based on their source (facility) and severity (priority) and route them to different files, 
			       remote servers, or databases. This is configured in `/etc/rsyslog.conf` and files in `/etc/rsyslog.d/`.
    *   Protocol Support: It can receive logs over the network (UDP/TCP), which is crucial for centralized logging servers.
*   The Relationship with journald: On most modern systems, `rsyslog` works in tandem with `journald`. 
	By default, `rsyslog` reads messages from the `journal` (via the `imjournal` input module) and then processes them according to its rules, 
	writing them out to the familiar text files in `/var/log/`. 
	This gives you the best of both worlds: the rich metadata of the journal and the robust filtering/routing of rsyslog.

#### Direct Write - Not recommended
#======================================#
*   What it is: This is when an application bypasses the system's logging daemons (`journald` or `rsyslog`) and writes directly to a file.
*   Why it's used:
    *   Legacy Applications: Older applications were designed to open a file like `/var/log/myapp.log` and write to it directly.
    *   Performance: For extremely high-throughput applications, the overhead of going through a logging socket might be a concern.
    *   Application Control: The application wants full control over the log format and rotation without relying on the system's rules.
*   The Downside: This bypasses the centralized management and features of `journald` and `rsyslog`. 
	The system administrator now has to manage log rotation for this specific file (e.g., using `logrotate`) and won't see these messages in `journalctl` by default.

### Summary and Typical Data Flow on a Modern System
#====================================================#
1.  An event occurs (e.g., a user logs in via SSH).
2.  The `sshd` process generates a log message.
3.  The message is sent to `systemd-journald` (via stdout/stderr since it's a systemd service). It is now stored in the binary journal and queryable with `journalctl`.
4.  `rsyslogd` is simultaneously listening to the journal. It picks up the message.
5.  `rsyslogd` checks its rules. It sees the message is from the `auth` facility with a `info` priority.
6.  Based on its configuration, `rsyslogd` appends this message to the text file `/var/log/auth.log`.
7.  (Optional) The application might also write directly to its own file, e.g., `/var/log/sshd.log`.

In short: You use `journalctl` for interactive, powerful filtering and debugging on the local machine. 
	  You use `rsyslog` for reliable, persistent text-based logging, complex filtering, and sending logs to a central server. 
	  You manage direct writes on a per-application basis.
#=============================================================================================================================================================================#

journalctl (2X TAB)
Display all 106 possibilities? (y or n)
	It gives a list of 106 fields that you can use to filter those log entries.

# Some Most Useful Fields
	Field			Meaning & Use Case
	_SYSTEMD_UNIT		The systemd service name. Essential for filtering by service. (-u is a shortcut for this).
	_COMM			The executable name. (e.g., bash, sshd, nginx). Good for finding logs from a specific program.
	_PID			Process ID. Great for debugging a specific, short-lived process.
	_UID			User ID. Find all actions performed by a specific user.
	_BOOT_ID		Boot session identifier. Used to filter logs from a specific boot.
*******************************************************Important******************************************************************
	PRIORITY		Log severity level (0=emerg, 1=alert, 2=crit, 3=err, 4=warning, 5=notice, 6=info, 7=debug). Use with -p.

journalctl _PID=2950 -p 3
# This will show priorities: err (3), crit (2), alert (1), emerg (0)
journalctl _PID=2950 -p 4
# This will show priorities: warning (4), err (3), crit (2), alert (1), emerg (0)
journalctl _PID=2950 -p 4..2
# Shows warning(4), err(3), crit(2)
journalctl _PID=2950 | grep -i error
#Show only lines containing the word "error" (case-insensitive)
journalctl _PID=2950 | grep -i -E "error|fail|warning"
# To show lines containing "error" OR "fail" OR "warning"
journalctl _PID=2950 | grep -i failed
# To show lines containing "failed"

# Understanding the Priority Levels
	Here's a quick reference for the -p flag numbers:
Number	Priority	Meaning								Approximate Lines per Day	
#---------------------------------------------------------------------------------------------------------------------------
0	emerg		System is unusable							0
1	alert		Action must be taken immediately					2
2	crit		Critical conditions							10
3	err		Error conditions (Your libinput error messages are here)		1,000
4	warning		Warning conditions (Your Window manager warning messages are here)	4,000
5	notice		Normal but significant condition					5,000
6	info		Informational messages							50,000
7	debug		Debug-level messages							500,000+
#-------------------------------------------------------------------------------------------------------------------------------

For Panic Situations
	journalctl -u my-database.service -p 0..1
For General Troubleshooting
	journalctl -p 0..3 --since "1 hour ago"
For Proactive Monitoring
	journalctl -u apache2.service -p 4
For Auditing and Verification
	journalctl -p 5 | grep -i "accepted\|login"
# Actions to be taken
#=================================
Priorities 0-3 (emerg - err): 
	REACT. Something is broken or about to break.
Priority 4 (warning): 
	MONITOR. Something is odd and should be investigated when you have time.
Priorities 5-7 (notice - debug): 
	IGNORE for daily operations. Use them for auditing (notice) or deep debugging (debug).
# log lines pyramid
#=====================
Why This Pyramid Exists
--- Cost: Storing 560,000 lines of logs every day is expensive. You want to keep the noisy debug logs only for short periods, but you might archive errors and above for years.
--- Performance: Writing to disk for every single operation (debug) slows an application down significantly.
--- Clarity: The whole point of the priority system is to amplify important signals and suppress noise. 
	If everything is logged as info, then truly important error messages get lost in the flood.

*********************************************************************************************************************************************
	_HOSTNAME		Source hostname. Crucial on a central log server storing logs from multiple machines.
	SYSLOG_IDENTIFIER	The name of the application as it identifies itself to the logging system.
	MESSAGE			The actual log message text. This is what you traditionally think of as the "log".
	_EXE			Path to the executable for the process that generated the log.
	_CMDLINE		Full command line used to invoke the process.

# takeaway for journalctl
	When you run journalctl by itself, you are seeing all levels, which is overwhelmingly Info and Debug noise.
	To be an effective debugger, you should almost always filter to the "actionable" priorities:
# Show me only things that are broken or might break soon.
# This filters out 98% of the logs and shows you the important 2%.
	journalctl -p 4..0
# Show me only things that are actively broken (high-priority todo list).
# This filters out 99.8% of the logs.
	journalctl -p 3..0
This transforms journalctl from a firehose of information into a precise tool for finding and fixing problems.
#======================================================================================================================================================================#

# Classic Text Log Files (in /var/log/)
	These are the traditional, human-readable text files. rsyslog often creates these by reading from the journal.

Log File		Purpose & Explanation
syslog / messages	The main catch-all log. General system activity, non-critical messages from many services and the kernel. (Debian/Ubuntu: syslog; RHEL/CentOS: messages).
auth.log / secure	Security & Authentication Log. All login attempts (successful/failed), sudo commands, SSH activity. First place to look for breaches. (Debian/Ubuntu: auth.log; RHEL/CentOS: secure).
kern.log		Kernel Log. Low-level messages from the Linux kernel: hardware detection, driver errors, filesystem issues.
boot.log		System Boot Log. Messages related specifically to the system startup process.
dmesg			Kernel Ring Buffer. Not a file you cat, but use the dmesg command to view recent kernel messages, especially useful for troubleshooting hardware.
Application Logs	Service-Specific Logs. Many applications write to their own log files or subdirectories in /var/log/.
(e.g., nginx/, apache2/, mysql/)	• apache2/access.log / nginx/access.log: Web server requests.		• mysql/error.log: Database errors.


# Key Differences: /var/log/ Text Files vs. /var/log/journal/
	Feature			Classic Text Logs (/var/log/)			systemd Journal (/var/log/journal/)
#------------------------------------------------------------------------------------------------------------------------#
	Format			Human-readable text				Binary data (not directly readable)
	How to View		cat, tail, less, grep				journalctl command only
	Primary Location	/var/log/syslog, /var/log/auth.log, etc.	/var/log/journal/<machine-id>/*.journal
	Metadata		Basic (timestamp, hostname, message)		Rich (PID, UID, GID, unit name, exe path, etc.)
	Main Tool		rsyslog or syslog-ng				systemd-journald
#-------------------------------------------------------------------------------------------------------------------------#

#Where to Look First
	"Why won't my service start?": 			journalctl -u service-name
	"Who logged in and when?": 			sudo tail -f /var/log/auth.log
	"Is there a hardware error?": 			journalctl -p 3 or dmesg -l err
	"What happened recently?": 			journalctl -e (jumps to end) or sudo tail -f /var/log/syslog

#-------------------------------------------------------FILTERING----------------------------------------------------------#
1. Filter by Priority 
journalctl -p 3						shows only error
journalctl -p 4						Show WARNINGs (4) and more severe (this includes both warnings and errors)
journalctl -p 4..2					Show a specific range (e.g., from WARNING to CRITICAL)

2. Filter by Timeframe
journalctl --since "1 hour ago"				Show logs from the last hour
journalctl --since "today"				Show logs from today
journalctl --since "yesterday"				Show logs from yesterday
journalctl --since "1 week ago"				Show logs from the last week
journalctl --since "last monday" --until "last friday"	Show logs for a specific date range (e.g., last Monday to last Friday)

3. Combining Priority and Time
This is the power of journalctl
journalctl -p 3 --since "1 hour ago"			Show me all ERRORS from the last hour	
journalctl -u ssh --since "today"			Show me everything from my SSH service today.
journalctl -u nginx -p 3 --since "yesterday"		Show me errors from my Nginx service in the last day.
journalctl -p 3 --since "1 hour ago"			What broke in the last hour? (same as 3.1 cmd)

4. With jornalctl simplicity what we are avoiding
Find errors in the last 2 hours of /var/log/syslog:
	sudo awk -v d1="$(date --date='2 hours ago' +'%b %_d %H:%M:%S')" -v d2="$(date +'%b %_d %H:%M:%S')" '$0 > d1 && $0 < d2' /var/log/syslog | grep -i error
Find errors in today's /var/log/syslog:
	sudo grep -i error /var/log/syslog | grep "$(date +'%b %_d')"
# Imp takeawy from filtering
-p for priority
--since
--until

#========================================================================================================================================================================#
# to see the all system logs live
universal cmd ===>>> journalctl -f
# General System Messages
tail -f /var/log/syslog or var/log/messages
# Login & Security Messages
tail -f /var/log/auth.log or var/log/secure 

# on new terminal enter 
logger 'Hello'
# or any message you want to pass that will automatically get added in journactl -f

# Ubuntu	RHEL
syslog		messages
auth.log	secure

# General System Messages
tail -f /var/log/syslog or var/log/messages
# Login & Security Messages
tail -f /var/log/auth.log or var/log/secure

# To see verbose output 
journalctl -o verbose|wc -l
8394140

# Log Rotation in /var/log/journal/
--- Yes, the journal has sophisticated, automatic internal rotation. 
--- You don't manage it with traditional tools like logrotate. 
--- Instead, systemd-journald handles its own rotation based on two primary settings:

• Time-based rotation: Keep logs for a certain time period.
• Size-based rotation: Keep logs until a certain total size is used.

journalctl --disk-usage
#  journald configuration file
sudo nano /etc/systemd/journald.conf

# Compares to Traditional Log Rotation
Feature			Traditional Logs (/var/log/syslog)	systemd Journal (/var/log/journal/)
#-----------------------------------------------------------------------------------------------------#
Rotation Tool		logrotate				journalctl --vacuum-* & journald.conf
Configuration		/etc/logrotate.conf			/etc/systemd/journald.conf
			/etc/logrotate.d/
Output			Creates .1, .gz files 			Creates archived *.journal files
			(syslog.1, syslog.2.gz)	
Action Command		Runs daily via cron			Managed continuously by systemd-journald

Journal rotation is automatic and configured in /etc/systemd/journald.conf.
Use journalctl --vacuum-* commands to manually clean up old logs or set policy.
The classic text logs in /var/log/ (like syslog, auth.log) are still rotated by the logrotate utility, which operates independently from the journal.

#====================================================================================================================================================================#

# systemd Journal Persistence

On a default Ubuntu installation, `systemd-journald` is configured for volatile (non-persistent) storage. This means:

*   Location: Logs are stored only in `/run/log/journal/`.
*   Persistence: The `/run/` filesystem is a tmpfs (a filesystem stored in RAM).
*   Result: All journal logs are lost forever when the system reboots or shuts down.

This is the default behavior on many Ubuntu setups to avoid wearing out SSDs on personal machines and to keep the log size small if the user doesn't need the history.

### The Two Modes of systemd-journald

| Mode 		| Storage Location    | Persistence 		   | Default on Ubuntu |
| Volatile 	| `/run/log/journal/` | NO. Lost on reboot. 	   | Yes (often) |
| Persistent 	| `/var/log/journal/` | YES. Saved across reboots. | No (unless you create the directory) |

### How to Check Your Current Mode

You can easily check which mode your system is using with this command:

journalctl --header | grep Storage

*   If the output is `Storage: volatile`, 	your logs are stored in `/run/log/journal/` and are not persistent.
*   If the output is `Storage: persistent`,	your logs are stored in `/var/log/journal/` and will survive a reboot.

# How to Enable Persistent Journaling (If Needed)
Follow these steps only if you need logs to survive a reboot.

# Step 1: Create the journal directory
	sudo mkdir /var/log/journal
# Step 2: Set correct ownership
(Gives the systemd-journald service permission to write to the directory)
	sudo chown root:systemd-journal /var/log/journal
# Step 3: Set secure permissions
(The setgid bit (2) ensures all new files inherit the correct group)
	sudo chmod 2755 /var/log/journal
#Step 4: Restart the journal service
(Forces systemd-journald to detect the new directory and switch to persistent mode)
	sudo systemctl restart systemd-journald
# Step 5: Verify it worked
	journalctl --header | grep Storage
# Expected output: Storage: persistent

# How to Manage and Rotate Persistent Logs
Persistent logs can grow large. Manage them with journalctl vacuum commands.

Check current disk usage:
	journalctl --disk-usage
Set a retention policy (Choose one):
Keep logs for a specific time period (e.g., 2 weeks):
	sudo journalctl --vacuum-time=2weeks
Keep logs until they reach a certain size (e.g., 500 MB):
	sudo journalctl --vacuum-size=500M
Make retention policies permanent:
Edit the configuration file:
	sudo nano /etc/systemd/journald.conf
Uncomment and modify these lines:
	[Journal]
	SystemMaxUse=500M
	#MaxRetentionSec=2week
Restart the service after changes:
	sudo systemctl restart systemd-journald

# How to Use Persistent Logs After a Reboot
This is the main benefit. You can view logs from previous boot sessions.
View logs from the previous boot:
	journalctl --boot=-1
View logs from two boots ago:
	journalctl --boot=-2
List all available boot sessions:
	journalctl --list-boots

In summary: Without you creating the `/var/log/journal/` directory, journaling is not persistent and is only available in the in-memory `/run/log/journal/` path, 
	where it disappears on reboot.
