# Configure logs
# locate and interpret system log files and journals
# preserve system journals

# What is system logging: 
 It is the mechanism by which a computer's operating system, its running services, and applications record events of interest. 
 Think of it as the "black box" or the "flight recorder" for your computer.
 These logs are sequential text files (though they can be in a binary format for efficiency) that contain timestamped messages. 
 They provide a continuous, historical record of everything that happens on the system, from routine status updates to critical security alerts.

man -k systemd  tail

### 2. What Comes In It? (The Contents of Logs)
Log entries are generated by a wide variety of system components. Here are the most common sources:

*   The Linux Kernel: Messages about hardware detection, driver errors, filesystem issues, and other low-level events. 
                        (e.g., `kernel: usb 2-1.2: new high-speed USB device number 5 using ehci-pci`)
*   System Services (Daemons): Services like web servers (Apache/Nginx), SSH, cron, and databases log their activity, errors, and connections. 
			(e.g., `sshd[1234]: Accepted password for user from 192.168.1.10 port 54322`)
*   Systemd itself: Logs for the boot process, service failures, and state changes of units. 
			(e.g., `systemd[1]: Started User Manager for UID 1000.`)
*   Security & Authentication: Successful and failed login attempts, privilege escalations (sudo), and firewall events. This is crucial for auditing and security.
*   Applications: User-level applications often write to system logs or their own application-specific log files.
*   System Events: Shutdowns, reboots, and scheduled tasks (cron jobs).

A typical log line looks like this:
			`May 15 10:23:45 my-server sshd[1234]: Accepted publickey for user from 192.168.1.100 port 55122 ssh2`

*   `May 15 10:23:45`: Timestamp
*   `my-server`: Hostname
*   `sshd[1234]`: The application/process and its PID
*   `Accepted publickey...`: The actual event message.

### 3. Why Do We Use It? (The Purpose)
Logging is not just for when things go wrong; it's essential for many aspects of system management:

1.  Debugging and Troubleshooting: This is the most common use. 
 When a service fails, a website goes down, or hardware acts strangely, the log files are the first place to look for error messages and clues.
2.  Security and Auditing: Logs are vital for detecting intrusion attempts, malicious activity, and policy violations. 
 They allow you to answer questions like "Who logged in and when?" or "Was there a failed login attempt for the root account?"
3.  Performance Monitoring: By analyzing logs over time, you can identify trends, spot resource bottlenecks, and understand system usage patterns.
4.  Forensics: After a security incident, logs provide a timeline of events to understand how the breach occurred and what the attacker did.
5.  Compliance: Many industry regulations (like PCI DSS, HIPAA, SOX) require logging and the retention of those logs for a specific period to prove the security and integrity of systems.


### 4. The Tools: systemd-journald, rsyslog, and Direct Writes
Modern Linux systems (most distributions since ~2015) use a combination of these tools.

#### systemd-journald - MODERN
#=================================#
*   What it is: The newer, default logging system introduced by `systemd`. It's more than just a daemon; it's integrated into the core of the OS.
*  Key Characteristics:
    *   Binary Format: It doesn't write to plain text files by default. Instead, it uses a binary, indexed file (usually `/var/log/journal/`). 
	This allows for much faster queries and richer metadata (like _PID, UID, GID, SELinux context_).
    *   Centralized Storage: It collects messages from the kernel (read from `kmsg`), early boot stages, and all systemd services via their std output (`stdout`) and std error (`stderr`).
    *   Temporary by Default: On some distributions, the journal is stored only in memory (`/run/log/journal/`) by default and is lost on reboot. 
	To make it persistent, you create the directory `/var/log/journal/` and restart `journald`.

*   How to use it: The primary tool to query the journal is `journalctl`.
	
	man -k journalctl
# useful options
-f = live logs
-b = bootlogs
-x = additional explaination on the logged item
-u = to filter specific unit only
-p = filtering of messages based on priority

    * journalctl									: View all logs
    * journalctl -u nginx.service							: View logs for the nginx service
    * journalctl -f									: Follow (tail) new log entries
    * journalctl --since "2023-05-15 09:00:00"						: Show logs since a specific time
    * journalctl --since "2025-07-01 00:00:00" --until "2025-08-01 23:59:59"		: show logs between two time limits
    * journalctl --since "2025-07-01" --until "2025-08-02" -u nginx.service		: show logs between two time limits for specific services like SSH, Docker, etc
    * journalctl _PID=1234								: Show logs for a specific Process ID (shows the power of metadata)

#### rsyslogd (or syslog) - OLD
#===============================#
*   What it is: The traditional, mature, and highly robust logging daemon. 
                `rsyslog` is the "rocket-fast" enhanced version of the original `sysklogd`. 
		It follows the classic syslog protocol.
*   Key Characteristics:
    *   Text-Based: It writes to classic, human-readable text files in `/var/log/` (e.g., `syslog`, `auth.log`, `kern.log`).
    *   Filtering and Routing: Its superpower is its ability to filter messages based on their source (facility) and severity (priority) and route them to different files, 
			       remote servers, or databases. This is configured in `/etc/rsyslog.conf` and files in `/etc/rsyslog.d/`.
    *   Protocol Support: It can receive logs over the network (UDP/TCP), which is crucial for centralized logging servers.
*   The Relationship with journald: On most modern systems, `rsyslog` works in tandem with `journald`. 
	By default, `rsyslog` reads messages from the `journal` (via the `imjournal` input module) and then processes them according to its rules, 
	writing them out to the familiar text files in `/var/log/`. 
	This gives you the best of both worlds: the rich metadata of the journal and the robust filtering/routing of rsyslog.

#### Direct Write - Not recommended
#======================================#
*   What it is: This is when an application bypasses the system's logging daemons (`journald` or `rsyslog`) and writes directly to a file.
*   Why it's used:
    *   Legacy Applications: Older applications were designed to open a file like `/var/log/myapp.log` and write to it directly.
    *   Performance: For extremely high-throughput applications, the overhead of going through a logging socket might be a concern.
    *   Application Control: The application wants full control over the log format and rotation without relying on the system's rules.
*   The Downside: This bypasses the centralized management and features of `journald` and `rsyslog`. 
	The system administrator now has to manage log rotation for this specific file (e.g., using `logrotate`) and won't see these messages in `journalctl` by default.

### Summary and Typical Data Flow on a Modern System
#====================================================#
1.  An event occurs (e.g., a user logs in via SSH).
2.  The `sshd` process generates a log message.
3.  The message is sent to `systemd-journald` (via stdout/stderr since it's a systemd service). It is now stored in the binary journal and queryable with `journalctl`.
4.  `rsyslogd` is simultaneously listening to the journal. It picks up the message.
5.  `rsyslogd` checks its rules. It sees the message is from the `auth` facility with a `info` priority.
6.  Based on its configuration, `rsyslogd` appends this message to the text file `/var/log/auth.log`.
7.  (Optional) The application might also write directly to its own file, e.g., `/var/log/sshd.log`.

In short: You use `journalctl` for interactive, powerful filtering and debugging on the local machine. 
	  You use `rsyslog` for reliable, persistent text-based logging, complex filtering, and sending logs to a central server. 
	  You manage direct writes on a per-application basis.
#=============================================================================================================================================================================#

journalctl (2X TAB)
Display all 106 possibilities? (y or n)
	It gives a list of 106 fields that you can use to filter those log entries.

# Some Most Useful Fields
	Field			Meaning & Use Case
	_SYSTEMD_UNIT		The systemd service name. Essential for filtering by service. (-u is a shortcut for this).
	_COMM			The executable name. (e.g., bash, sshd, nginx). Good for finding logs from a specific program.
	_PID			Process ID. Great for debugging a specific, short-lived process.
	_UID			User ID. Find all actions performed by a specific user.
	_BOOT_ID		Boot session identifier. Used to filter logs from a specific boot.
*Important
	PRIORITY		Log severity level (0=emerg, 1=alert, 2=crit, 3=err, 4=warning, 5=notice, 6=info, 7=debug). Use with -p.

journalctl _PID=2950 -p 3
# This will show priorities: err (3), crit (2), alert (1), emerg (0)
journalctl _PID=2950 -p 4
# This will show priorities: warning (4), err (3), crit (2), alert (1), emerg (0)
journalctl _PID=2950 -p 4..2
# Shows warning(4), err(3), crit(2)
journalctl _PID=2950  grep -i error
#Show only lines containing the word "error" (case-insensitive)
journalctl _PID=2950  grep -i -E "errorfailwarning"
# To show lines containing "error" OR "fail" OR "warning"
journalctl _PID=2950  grep -i failed
# To show lines containing "failed"

# Understanding the Priority Levels
	Here's a quick reference for the -p flag numbers:
Number	Priority	Meaning								Approximate Lines per Day	
#------------------------------------------------------------------------------------------------------------------------#
0	emerg		System is unusable							0
1	alert		Action must be taken immediately					2
2	crit		Critical conditions							10
3	err		Error conditions (Your libinput error messages are here)		1,000
4	warning		Warning conditions (Your Window manager warning messages are here)	4,000
5	notice		Normal but significant condition					5,000
6	info		Informational messages							50,000
7	debug		Debug-level messages							500,000+
#------------------------------------------------------------------------------------------------------------------------#

For Panic Situations
	journalctl -u my-database.service -p 0..1
For General Troubleshooting
	journalctl -p 0..3 --since "1 hour ago"
For Proactive Monitoring
	journalctl -u apache2.service -p 4
For Auditing and Verification
	journalctl -p 5  grep -i "accepted\login"
# Actions to be taken
#=================================
Priorities 0-3 (emerg - err): 
	REACT. Something is broken or about to break.
Priority 4 (warning): 
	MONITOR. Something is odd and should be investigated when you have time.
Priorities 5-7 (notice - debug): 
	IGNORE for daily operations. Use them for auditing (notice) or deep debugging (debug).
# log lines pyramid
#=====================
Why This Pyramid Exists
 Cost: Storing 560,000 lines of logs every day is expensive. You want to keep the noisy debug logs only for short periods, but you might archive errors and above for years.
 Performance: Writing to disk for every single operation (debug) slows an application down significantly.
 Clarity: The whole point of the priority system is to amplify important signals and suppress noise. 
	If everything is logged as info, then truly important error messages get lost in the flood.

*
	_HOSTNAME		Source hostname. Crucial on a central log server storing logs from multiple machines.
	SYSLOG_IDENTIFIER	The name of the application as it identifies itself to the logging system.
	MESSAGE			The actual log message text. This is what you traditionally think of as the "log".
	_EXE			Path to the executable for the process that generated the log.
	_CMDLINE		Full command line used to invoke the process.

# takeaway for journalctl
	When you run journalctl by itself, you are seeing all levels, which is overwhelmingly Info and Debug noise.
	To be an effective debugger, you should almost always filter to the "actionable" priorities:
# Show me only things that are broken or might break soon.
# This filters out 98% of the logs and shows you the important 2%.
	journalctl -p 4..0
# Show me only things that are actively broken (high-priority todo list).
# This filters out 99.8% of the logs.
	journalctl -p 3..0
This transforms journalctl from a firehose of information into a precise tool for finding and fixing problems.
#======================================================================================================================================================================#

# Classic Text Log Files (in /var/log/)
	These are the traditional, human-readable text files. rsyslog often creates these by reading from the journal.

Log File		Purpose & Explanation
syslog / messages	The main catch-all log. General system activity, non-critical messages from many services and the kernel. (Debian/Ubuntu: syslog; RHEL/CentOS: messages).
auth.log / secure	Security & Authentication Log. All login attempts (successful/failed), sudo commands, SSH activity. First place to look for breaches. (Debian/Ubuntu: auth.log; RHEL/CentOS: secure).
kern.log		Kernel Log. Low-level messages from the Linux kernel: hardware detection, driver errors, filesystem issues.
boot.log		System Boot Log. Messages related specifically to the system startup process.
dmesg			Kernel Ring Buffer. Not a file you cat, but use the dmesg command to view recent kernel messages, especially useful for troubleshooting hardware.
Application Logs	Service-Specific Logs. Many applications write to their own log files or subdirectories in /var/log/.
(e.g., nginx/, apache2/, mysql/)	• apache2/access.log / nginx/access.log: Web server requests.		• mysql/error.log: Database errors.


# Key Differences: /var/log/ Text Files vs. /var/log/journal/
	Feature			Classic Text Logs (/var/log/)			systemd Journal (/var/log/journal/)
##
	Format			Human-readable text				Binary data (not directly readable)
	How to View		cat, tail, less, grep				journalctl command only
	Primary Location	/var/log/syslog, /var/log/auth.log, etc.	/var/log/journal/<machine-id>/*.journal
	Metadata		Basic (timestamp, hostname, message)		Rich (PID, UID, GID, unit name, exe path, etc.)
	Main Tool		rsyslog or syslog-ng				systemd-journald
#-#

#Where to Look First
	"Why won't my service start?": 			journalctl -u service-name
	"Who logged in and when?": 			sudo tail -f /var/log/auth.log
	"Is there a hardware error?": 			journalctl -p 3 or dmesg -l err
	"What happened recently?": 			journalctl -e (jumps to end) or sudo tail -f /var/log/syslog

#-FILTERING-#
1. Filter by Priority 
journalctl -p 3						shows only error
journalctl -p 4						Show WARNINGs (4) and more severe (this includes both warnings and errors)
journalctl -p 4..2					Show a specific range (e.g., from WARNING to CRITICAL)

2. Filter by Timeframe
journalctl --since "1 hour ago"				Show logs from the last hour
journalctl --since "today"				Show logs from today
journalctl --since "yesterday"				Show logs from yesterday
journalctl --since "1 week ago"				Show logs from the last week
journalctl --since "last monday" --until "last friday"	Show logs for a specific date range (e.g., last Monday to last Friday)

3. Combining Priority and Time
This is the power of journalctl
journalctl -p 3 --since "1 hour ago"			Show me all ERRORS from the last hour	
journalctl -u ssh --since "today"			Show me everything from my SSH service today.
journalctl -u nginx -p 3 --since "yesterday"		Show me errors from my Nginx service in the last day.
journalctl -p 3 --since "1 hour ago"			What broke in the last hour? (same as 3.1 cmd)

4. With jornalctl simplicity what we are avoiding
Find errors in the last 2 hours of /var/log/syslog:
	sudo awk -v d1="$(date --date='2 hours ago' +'%b %_d %H:%M:%S')" -v d2="$(date +'%b %_d %H:%M:%S')" '$0 > d1 && $0 < d2' /var/log/syslog  grep -i error
Find errors in today's /var/log/syslog:
	sudo grep -i error /var/log/syslog  grep "$(date +'%b %_d')"
# Imp takeawy from filtering
-p for priority
--since
--until

#========================================================================================================================================================================#
# to see the all system logs live
universal cmd ===>>> journalctl -f
# General System Messages
tail -f /var/log/syslog or var/log/messages
# Login & Security Messages
tail -f /var/log/auth.log or var/log/secure 

# on new terminal enter 
logger 'Hello'
# or any message you want to pass that will automatically get added in journactl -f

# Ubuntu	RHEL
syslog		messages
auth.log	secure

# General System Messages
tail -f /var/log/syslog or var/log/messages
# Login & Security Messages
tail -f /var/log/auth.log or var/log/secure

# To see verbose output 
journalctl -o verbosewc -l
8394140

# Log Rotation in /var/log/journal/
 Yes, the journal has sophisticated, automatic internal rotation. 
 You don't manage it with traditional tools like logrotate. 
 Instead, systemd-journald handles its own rotation based on two primary settings:

• Time-based rotation: Keep logs for a certain time period.
• Size-based rotation: Keep logs until a certain total size is used.

journalctl --disk-usage
#  journald configuration file
sudo nano /etc/systemd/journald.conf

# Compares to Traditional Log Rotation
Feature			Traditional Logs (/var/log/syslog)	systemd Journal (/var/log/journal/)
#----------------------------------------------------------------------------------------------------------#
Rotation Tool		logrotate				journalctl --vacuum-* & journald.conf
Configuration		/etc/logrotate.conf			/etc/systemd/journald.conf
			/etc/logrotate.d/
Output			Creates .1, .gz files 			Creates archived *.journal files
			(syslog.1, syslog.2.gz)	
Action Command		Runs daily via cron			Managed continuously by systemd-journald

Journal rotation is automatic and configured in /etc/systemd/journald.conf.
Use journalctl --vacuum-* commands to manually clean up old logs or set policy.
The classic text logs in /var/log/ (like syslog, auth.log) are still rotated by the logrotate utility, which operates independently from the journal.

#====================================================================================================================================================================#

# systemd Journal Persistence

On a default Ubuntu installation, `systemd-journald` is configured for volatile (non-persistent) storage. This means:

*   Location: Logs are stored only in `/run/log/journal/`.
*   Persistence: The `/run/` filesystem is a tmpfs (a filesystem stored in RAM).
*   Result: All journal logs are lost forever when the system reboots or shuts down.

This is the default behavior on many Ubuntu setups to avoid wearing out SSDs on personal machines and to keep the log size small if the user doesn't need the history.

### The Two Modes of systemd-journald

 Mode 		 Storage Location     Persistence 		    Default on Ubuntu 
 Volatile 	 `/run/log/journal/`  NO. Lost on reboot. 	    Yes (often) 
 Persistent 	 `/var/log/journal/`  YES. Saved across reboots.  No (unless you create the directory) 

### How to Check Your Current Mode

You can easily check which mode your system is using with this command:

journalctl --header  grep Storage

*   If the output is `Storage: volatile`, 	your logs are stored in `/run/log/journal/` and are not persistent.
*   If the output is `Storage: persistent`,	your logs are stored in `/var/log/journal/` and will survive a reboot.

# How to Enable Persistent Journaling (If Needed)
Follow these steps only if you need logs to survive a reboot.

# Step 1: Create the journal directory
	sudo mkdir /var/log/journal
# Step 2: Set correct ownership
(Gives the systemd-journald service permission to write to the directory)
	sudo chown root:systemd-journal /var/log/journal
# Step 3: Set secure permissions
(The setgid bit (2) ensures all new files inherit the correct group)
	sudo chmod 2755 /var/log/journal
#Step 4: Restart the journal service
(Forces systemd-journald to detect the new directory and switch to persistent mode)
	sudo systemctl restart systemd-journald
# Step 5: Verify it worked
	journalctl --header | grep Storage
# Expected output: Storage: persistent

# How to Manage and Rotate Persistent Logs
Persistent logs can grow large. Manage them with journalctl vacuum commands.

Check current disk usage:
	journalctl --disk-usage
Set a retention policy (Choose one):
Keep logs for a specific time period (e.g., 2 weeks):
	sudo journalctl --vacuum-time=2weeks
Keep logs until they reach a certain size (e.g., 500 MB):
	sudo journalctl --vacuum-size=500M
Make retention policies permanent:
Edit the configuration file:
	sudo nano /etc/systemd/journald.conf
Uncomment and modify these lines:
	[Journal]
	SystemMaxUse=500M
	#MaxRetentionSec=2week
Restart the service after changes:
	sudo systemctl restart systemd-journald

# How to Use Persistent Logs After a Reboot
This is the main benefit. You can view logs from previous boot sessions.
View logs from the previous boot:
	journalctl --boot=-1
View logs from two boots ago:
	journalctl --boot=-2
List all available boot sessions:
	journalctl --list-boots

In summary: Without you creating the `/var/log/journal/` directory, journaling is not persistent and is only available in the in-memory `/run/log/journal/` path, 
	where it disappears on reboot.

#=================================================================================================================================================#

# Rsyslog
#---------------#
### The Rsyslog Configuration: Concepts and Practical Analysis

This explains the core concepts of `rsyslog` and then applies them directly to  Ubuntu system's configuration file.

### Part 1: Core Concepts of Rsyslog
Rsyslog's job is to process log messages by filtering them based on their properties and then sending them to a destination. 
It does this using rules defined in its configuration files.

#### 1. Configuration Files
Rsyslog's configuration is modular. The main files are:
*   `/etc/rsyslog.conf`: The primary configuration file that loads modules and sets global directives.
*   `/etc/rsyslog.d/*.conf`: Files in this directory are included. This is where custom rules live. 
			     Your file, `/etc/rsyslog.d/50-default.conf`, is where the standard rules are defined.

#### 2. The Anatomy of a Rule: Selector + Action
Every active line in your config is a rule with two parts:
*   Selector: The filter to match messages (based on Facility and Priority).
*   Action: The destination to send matching messages.

#### 3. Facilities (The "Who")
A facility categorizes the subsystem that generated the message.

 Facility  		Description  				Example in  Config 
 `auth`, `authpriv`  	Security/authorization messages  	`auth,authpriv.*` 
 `kern`  		Kernel messages  			`kern.*` 
 `mail`  		Mail system  				`mail.*`, `mail.err` 
 `cron`  		Cron daemon  				`#cron.*` (commented out) 
 `daemon`  		Other system daemons  			`#daemon.*` (commented out) 
 `*`  			Wildcard for "any facility"  		`*.*` 

#### 4. Priorities (The "How Bad")
A priority indicates the severity of the message, from highest to lowest.

 Priority  Keyword  	Description 
 0  	   `emerg`  	System is unusable 
 1  	   `alert`  	Action must be taken immediately 
 2  	   `crit`  	Critical conditions 
 3   	   `err`  	Error conditions 
 4  	   `warning`    Warning conditions 
 5  	   `notice`  	Normal but significant condition 
 6  	   `info`  	Informational messages 
 7  	   `debug`  	Debug-level messages 
 `none`    `none`  	Excludes a facility. 


#### 5. Actions (The "Where")
The action defines what to do with a matched message.

 Action  	Syntax  		Description  						Example in Config 
 File  		`/var/log/file.log`  	Write to a file.  					`/var/log/auth.log` 
 Async File  	`-/var/log/file.log`  	Write to a file asynchronously (better performance).  	`-/var/log/syslog` 
 User  		`:omusrmsg:*`  		Send to all logged-in users.  				`*.emerg :omusrmsg:*` 
 Discard  	`~`  			Delete the message (stop processing).  			`mail.debug ~` (commented) 


### Part 2: Practical Analysis of `50-default.conf` File
 cat /etc/rsyslog.d/50-default.conf 
Now, let's break down  active rules to see these concepts in action.

#### 1. Auth Rule: The Security Log
auth,authpriv.*                 /var/log/auth.log

*   Selector: `auth,authpriv.*` - Match ALL messages (`.*`) from the `auth` and `authpriv` facilities.
*   Action: `/var/log/auth.log` - Write them to the `/var/log/auth.log` file.
*   Purpose: This is  primary security log. It captures all authentication events: user logins (successful/failed), `sudo` commands, and SSH activity.

#### 2. Main Syslog Rule: The Catch-All
*.*;auth,authpriv.none          -/var/log/syslog

*   Selector: `*.*;auth,authpriv.none` - A multi-part selector:
    *   `*.*` - First, match ALL messages from all facilities and priorities.
    *   `auth,authpriv.none` - THEN, exclude any messages from the `auth` and `authpriv` facilities.
*   Action: `-/var/log/syslog` - Write the remaining messages asynchronously (`-`) to `/var/log/syslog`.
*   Purpose: This is  main system log. It's a catch-all for general system activity, but it excludes security messages because they are already handled by the previous, more specific rule. This prevents duplication.

#### 3. Kernel Rule: Hardware & Driver Logs
kern.*                          -/var/log/kern.log

*   Selector: `kern.*` - Match ALL messages from the `kern` (kernel) facility.
*   Action: `-/var/log/kern.log` - Write them asynchronously to their own file.
*   Purpose: Isolates low-level kernel messages. This is the first place to look for hardware detection, driver errors, or filesystem issues.

#### 4. & 5. Mail Rules: Application Logging
mail.*                          -/var/log/mail.log
mail.err                        /var/log/mail.err

*   Rule 4: `mail.* -/var/log/mail.log` captures all mail-related logs.
*   Rule 5: `mail.err /var/log/mail.err` captures only mail messages with a priority of `err` (error) or higher (i.e., `err`, `crit`, `alert`, `emerg`).
*   Purpose: This shows a common logging strategy:
    1.  Log everything for an application to one file (`mail.log`).
    2.  Log only severe errors to a dedicated file (`mail.err`) for easier monitoring and alerting.

#### 6. Emergency Rule: Critical Alerts
*.emerg                         :omusrmsg:*

*   Selector: `*.emerg` - Match messages with `emerg` priority from ANY facility.
*   Action: `:omusrmsg:*` - Send them to the terminals of all currently logged-in users.
*   Purpose: This is a critical broadcast system for system-wide emergencies. If the system is crashing, this ensures the message is seen.

### Summary and Best Practices
*   Order Matters: Rsyslog processes rules from top to bottom.  config uses a smart order: specific rules (like for `auth`) come before the general catch-all rule.
*   Syntax: The `;` character separates multiple conditions in a selector. The `.none` keyword is used for exclusion.
*   Commenting: The lines starting with `#` are inactive. They are examples provided by Ubuntu that you can activate by removing the `#` (e.g., `#cron.*` to enable cron logging).
*   Applying Changes: After any edit, always restart rsyslog: `sudo systemctl restart rsyslog`.

The `50-default.conf` file is a classic example of effective log management: 
it uses facilities and priorities to filter messages and route them to dedicated destination files, making the system much easier to monitor and debug.

#===============================================================================================================================================================#

# Log rotate
#----------------------------#

### The Simple Analogy

Think of log rotation like a school with rules for all students:

*   `/etc/logrotate.conf` is the school-wide rulebook. It sets the default rules for every student.
*   `/etc/logrotate.d/` is a folder of club-specific rules. Each club (like the Chess Club or Soccer Team) can have its own rules that override the school's defaults.

### The Technical Explanation with Examples

#### 1. `/etc/logrotate.conf` - The Global Default Rules
This file sets the fallback rules that apply to every log on the system, unless a specific rule in `/etc/logrotate.d/` says otherwise.

The system's global rules (`cat /etc/logrotate.conf`) say:
> "By default, for any log file, I want you to:
> *   Rotate it once a week (`weekly`)
> *   Keep only 4 old copies before deleting the oldest one (`rotate 4`)
> *   compress the old logs (if needed)
> *   Create a new empty log file after rotating (`create`)"

These are sensible, low-resource defaults.

#### 2. `/etc/logrotate.d/` - The Service-Specific Rule Overrides
This directory contains files that define custom rules for specific applications. These rules *override* the global defaults for the logs they control.

Let's see how two services in the folder override the global rules:
cat /etc/logrotate.d/nginx 
cat /etc/logrotate.d/mysql-server 

### Example 1: The NGINX Web Server (`/etc/logrotate.d/nginx`)
*   Global Default would be: Rotate weekly, keep 4 copies, no compression.
*   NGINX's Rule says: "For my logs (`/var/log/nginx/*.log`), ignore the global rules. Do this instead:
    *   Rotate daily (`daily`) - because web servers generate lots of logs fast.
    *   Keep 14 copies (`rotate 14`) - because you might need two weeks of logs to debug web traffic.
    *   Compress the old logs (`compress`) - to save disk space because the logs are large.
    *   Tell the NGINX process to start using the new log file after rotation (`postrotate` script). This step is critical and is unique to the NGINX service.


### Example 2: The MySQL Database Server (`/etc/logrotate.d/mysql-server`)
*   Global Default would be: Rotate weekly, keep 4 copies, no compression.
*   MySQL's Rule says: "For my logs, also override the defaults. Do this:
    *   Rotate daily (`daily`) - databases also generate many logs.
    *   Keep 7 copies (`rotate 7`) - a week of logs is sufficient.
    *   Compress the old logs (`compress`) - to save space.
    *   Tell the MySQL process to flush its logs properly using a special `mysqladmin` command (`postrotate` script). This specific command is unique to MySQL.


### How They Work Together: A Summary

	  	`/etc/logrotate.conf`  `/etc/logrotate.d/nginx` 
#--------------------------------------------------------------------#
 Role  		Global Defaults  	Service-Specific Overrides 
 Rotation  	`weekly`  		`daily` ← OVERRIDES 
 Retention  	`rotate 4`  		`rotate 14` ← OVERRIDES 
 Compression  	Off (`#compress`)  	On (`compress`) ← OVERRIDES 
 Special Action  -  			`invoke-rc.d nginx rotate` ← ADDS A NEW RULE 

The bottom line: The files in `/etc/logrotate.d/` are where the important, specific configurations happen. 
The main `logrotate.conf` file just provides a basic default for any other logs on the system that aren't important enough to have their own custom rule.

For creating log rotation file refer: logrotate.txt
